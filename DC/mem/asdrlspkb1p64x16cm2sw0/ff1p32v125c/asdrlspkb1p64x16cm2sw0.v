//---------------------------------------------------------------------
//               Copyright(c) Synopsys, Inc.                           
//     All Rights reserved - Unpublished -rights reserved under        
//     the Copyright laws of the United States of America.             
//                                                                     
//  U.S. Patents: 7,093,156 B1 and 7,406,620 B2 (and more pending).    
//                                                                     
//  This file includes the Confidential information of Synopsys, Inc.  
//  and Huali.                                                         
//  The receiver of this Confidential Information shall not disclose   
//  it to any third party and shall protect its confidentiality by     
//  using the same degree of care, but not less than a reasonable      
//  degree of care, as the receiver uses to protect receiver's own     
//  Confidential Information.                                          
//  Licensee acknowledges and agrees that all output generated for     
//  Licensee by Synopsys, Inc. as described in the pertinent Program   
//  Schedule(s), or generated by Licensee through use of any Compiler  
//  licensed hereunder contains information that complies with the     
//  Virtual Component Identification Physical Tagging Standard (VCID)  
//  as maintained by the Virtual Socket Interface Alliance (VSIA).     
//  Such information may be expressed in GDSII Layer 63 or other such  
//  layer designated by the VSIA, hardware definition languages, or    
//  other formats.  Licensee is not authorized to alter or change any  
//  such information.                                                  
//---------------------------------------------------------------------
//                                                                     
//  Built for linux64 and running on linux64.                          
//                                                                     
//  Software           : Rev: S-2021.12                                
//  Library Format     : Rev: 1.05.00                                  
//  Compiler Name      : hu55npkb1p11asdrl32ksa03p1                    
//  Platform           : Linux3.10.0-1160.49.1.el7.x86_64              
//                     : #1 SMP Tue Nov 30 15:51:32 UTC 2021x86_64     
//  Date of Generation : Fri Feb 18 10:17:47 CST 2022                  
//                                                                     
//---------------------------------------------------------------------
//   --------------------------------------------------------------     
//                       Template Revision : 3.7.8                      
//   --------------------------------------------------------------     
//                      * Synchronous, 1-Port SRAM *                  
//                      * Verilog Behavioral Model *                  
//                THIS IS A SYNCHRONOUS 1-PORT MEMORY MODEL           
//                                                                    
//   Memory Name:asdrlspkb1p64x16cm2sw0                               
//   Memory Size:64 words x 16 bits                                   
//                                                                    
//                               PORT NAME                            
//                               ---------                            
//               Output Ports                                         
//                                   Q[15:0]                          
//               Input Ports:                                         
//                                   ADR[5:0]                         
//                                   D[15:0]                          
//                                   WE                               
//                                   ME                               
//                                   CLK                              
//                                   TEST1                            
//                                   RM[3:0]                          
//                                   RME                              

`resetall 
`timescale 1 ns / 1 ps 
`celldefine 
`ifdef verifault // for fault simulation purpose 
`suppress_faults 
`enable_portfaults 
`endif 

`define True    1'b1
`define False   1'b0




module asdrlspkb1p64x16cm2sw0 ( Q, ADR, D, WE, ME, CLK, TEST1, RM, RME);

output  [15:0] Q;
input  [5:0] ADR;
input  [15:0] D;
input WE;
input ME;
input CLK;
input TEST1;
input  [3:0] RM;
input RME;


// Local registers, wires, etc

`ifdef MEM_CHECK_OFF
parameter MES_ALL = "OFF";
`else
parameter MES_ALL = "ON";
`endif // MEM_CHECK_OFF

`ifdef VIRAGE_IGNORE_SAME_ADDR_MSG
parameter debug_mode = 0;
`else
parameter debug_mode = 1;
`endif // VIRAGE_IGNORE_SAME_ADDR_MSG


`ifdef VIRAGE_FAST_VERILOG
`else
reg notif_adr;
reg notif_d;
reg notif_we;
reg notif_me;
reg notif_clk;
reg notif_test1;
reg notif_rm;
reg notif_rme;
`endif // VIRAGE_FAST_VERILOG

reg  [5 : 0 ] ADR_pre;
reg  ME_pre;
reg  WE_pre;





`ifdef VIRAGE_FAST_VERILOG
wire [15:0] Q_buf;
assign Q[0] = Q_buf[0];
assign Q[1] = Q_buf[1];
assign Q[2] = Q_buf[2];
assign Q[3] = Q_buf[3];
assign Q[4] = Q_buf[4];
assign Q[5] = Q_buf[5];
assign Q[6] = Q_buf[6];
assign Q[7] = Q_buf[7];
assign Q[8] = Q_buf[8];
assign Q[9] = Q_buf[9];
assign Q[10] = Q_buf[10];
assign Q[11] = Q_buf[11];
assign Q[12] = Q_buf[12];
assign Q[13] = Q_buf[13];
assign Q[14] = Q_buf[14];
assign Q[15] = Q_buf[15];
wire [5:0] ADR_buf;
assign  ADR_buf[0] =  ADR[0];
assign  ADR_buf[1] =  ADR[1];
assign  ADR_buf[2] =  ADR[2];
assign  ADR_buf[3] =  ADR[3];
assign  ADR_buf[4] =  ADR[4];
assign  ADR_buf[5] =  ADR[5];
wire [15:0] D_buf;
assign  D_buf[0] =  D[0];
assign  D_buf[1] =  D[1];
assign  D_buf[2] =  D[2];
assign  D_buf[3] =  D[3];
assign  D_buf[4] =  D[4];
assign  D_buf[5] =  D[5];
assign  D_buf[6] =  D[6];
assign  D_buf[7] =  D[7];
assign  D_buf[8] =  D[8];
assign  D_buf[9] =  D[9];
assign  D_buf[10] =  D[10];
assign  D_buf[11] =  D[11];
assign  D_buf[12] =  D[12];
assign  D_buf[13] =  D[13];
assign  D_buf[14] =  D[14];
assign  D_buf[15] =  D[15];
wire WE_buf;
assign  WE_buf =  WE;
wire ME_buf;
assign  ME_buf =  ME;
wire CLK_buf;
assign  CLK_buf =  CLK;
wire TEST1_buf;
assign  TEST1_buf =  TEST1;
wire [3:0] RM_buf;
assign  RM_buf[0] =  RM[0];
assign  RM_buf[1] =  RM[1];
assign  RM_buf[2] =  RM[2];
assign  RM_buf[3] =  RM[3];
wire RME_buf;
assign  RME_buf =  RME;
`else
wire [15:0] Q_buf;
buf (Q[0], Q_buf[0]);
buf (Q[1], Q_buf[1]);
buf (Q[2], Q_buf[2]);
buf (Q[3], Q_buf[3]);
buf (Q[4], Q_buf[4]);
buf (Q[5], Q_buf[5]);
buf (Q[6], Q_buf[6]);
buf (Q[7], Q_buf[7]);
buf (Q[8], Q_buf[8]);
buf (Q[9], Q_buf[9]);
buf (Q[10], Q_buf[10]);
buf (Q[11], Q_buf[11]);
buf (Q[12], Q_buf[12]);
buf (Q[13], Q_buf[13]);
buf (Q[14], Q_buf[14]);
buf (Q[15], Q_buf[15]);
wire [5:0] ADR_buf;
buf (ADR_buf[0], ADR[0]);
buf (ADR_buf[1], ADR[1]);
buf (ADR_buf[2], ADR[2]);
buf (ADR_buf[3], ADR[3]);
buf (ADR_buf[4], ADR[4]);
buf (ADR_buf[5], ADR[5]);
wire [15:0] D_buf;
buf (D_buf[0], D[0]);
buf (D_buf[1], D[1]);
buf (D_buf[2], D[2]);
buf (D_buf[3], D[3]);
buf (D_buf[4], D[4]);
buf (D_buf[5], D[5]);
buf (D_buf[6], D[6]);
buf (D_buf[7], D[7]);
buf (D_buf[8], D[8]);
buf (D_buf[9], D[9]);
buf (D_buf[10], D[10]);
buf (D_buf[11], D[11]);
buf (D_buf[12], D[12]);
buf (D_buf[13], D[13]);
buf (D_buf[14], D[14]);
buf (D_buf[15], D[15]);
buf (WE_buf, WE);
buf (ME_buf, ME);
buf (CLK_buf, CLK);
buf (TEST1_buf, TEST1);
wire [3:0] RM_buf;
buf (RM_buf[0], RM[0]);
buf (RM_buf[1], RM[1]);
buf (RM_buf[2], RM[2]);
buf (RM_buf[3], RM[3]);
buf (RME_buf, RME);
`endif // VIRAGE_FAST_VERILOG

`ifdef VIRAGE_FAST_VERILOG
`else
// Setup/hold condition for CLK: ENCLK
reg  ENCLK_P_reg,ENCLKI_P;
wire ENCLK;

always @( ME_buf )
begin
  ENCLK_P_reg = 1'b1; 
  if ( ENCLKI_P == 1'b1 )
     ENCLKI_P = 1'b0; 
end

always @(posedge CLK_buf)
begin
  #0.001; 
  if (ME_buf === 1'b0)
  begin
    if (ENCLKI_P == 1'b1)
      ENCLK_P_reg = 1'b0; 
    else    
      ENCLKI_P = 1'b1; 
  end
end

assign ENCLK = ENCLK_P_reg ;
wire ENCLK_rmezo,ENCLK_vdm,ENCLK_slw,ENCLK_def,ENCLK_fst;
assign ENCLK_rmezo = ENCLK_P_reg && RME_buf !== 1'b1 ;
assign ENCLK_vdm = ENCLK_P_reg && RME_buf === 1'b1  && ( (!RM_buf[0]) && (!RM_buf[1]) && (!RM_buf[2]) && (!RM_buf[3]) ) ;
assign ENCLK_slw = ENCLK_P_reg && RME_buf === 1'b1  && ( (RM_buf[0]) && (!RM_buf[1]) && (!RM_buf[2]) && (!RM_buf[3]) ) ;
assign ENCLK_def = ENCLK_P_reg && RME_buf === 1'b1  && ( (!RM_buf[0]) && (RM_buf[1]) && (!RM_buf[2]) && (!RM_buf[3]) ) ;
assign ENCLK_fst = ENCLK_P_reg && RME_buf === 1'b1  && ( (RM_buf[0]) && (RM_buf[1]) && (!RM_buf[2]) && (!RM_buf[3]) ) ;
`endif // VIRAGE_FAST_VERILOG

`ifdef VIRAGE_FAST_VERILOG
`else
wire ADR_valid;
assign ADR_valid = ( ( ADR_pre < 64 )?1'b1:1'b0);

wire ADR_valid_rec;
assign ADR_valid_rec = ( ( ADR_pre < 64  )?1'b1:1'b0);

`endif // VIRAGE_FAST_VERILOG

// Setup/hold conditions for syncronous signals
`ifdef VIRAGE_FAST_VERILOG
`else
// Setup/hold condition for Address: ADR is : ENADR
wire ENADR;
buf ( ENADR, ME_pre );
 
// Setup/hold condition for Memory Enable: ME is : ENME
wire ENME;
buf ( ENME, ADR_valid );

// Setup/hold condition for Write Enable: WE is : ENWE
wire ENWE;
assign ENWE = (( ADR_valid && ME_pre !== 1'b0  ) ?1'b1:1'b0);

// Setup/hold condition for Data In: D is : END
wire END;
assign END = (( ADR_valid && ME_pre !== 1'b0 && WE_pre !== 1'b0  )?1'b1:1'b0) ;
// Setup/hold condition for test1 Vector: TEST1 is : ENTEST1
wire ENTEST1;
assign ENTEST1 = ((ME_pre !== 1'b0 && ADR_valid )?1'b1:1'b0);
 
// Setup/hold condition for Read Margin Vector: RM is : ENRM
wire ENRM;
assign ENRM = ((ME_pre !== 1'b0 && ADR_valid && RME_buf !== 1'b0 )?1'b1:1'b0);
// Setup/hold condition for Read Margin Vector: RME is : ENRME
wire ENRME;
assign ENRME = ((ME_pre !== 1'b0 && ADR_valid)?1'b1:1'b0);

`endif // VIRAGE_FAST_VERILOG

reg ME_buf_L;
reg WE_buf_L;

`ifdef VIRAGE_FAST_VERILOG
`else
`endif // VIRAGE_FAST_VERILOG

`ifdef VIRAGE_FAST_VERILOG
`else
specify
 

    specparam

        Tac = 0.308,
        Tcax = 0.069,
        Tdc = 0.210,
        Tcdx = 0.049,
        Twc = 0.274,
        Tcwx = 0.059,
        Tmc = 0.325,
        Tcmx = 0.000,
        Tcl = 0.308,
        Tch = 0.116,
        Tcc = 0.570,
        Tccvddmin = 0.886,
        Tccslow = 0.627,
        Tccdef = 0.570,
        Tccfast = 0.564,
        Tt1c = 0.308,
        Tct1x = 0.570,
        Trmc = 0.175,
        Tcrmx = 0.570,
        Tcq = 0.447,
        Tcqx = 0.383,
        Tcqvddmin = 0.763,
        Tcqvddminx = 0.668,
        Tcqslow = 0.504,
        Tcqslowx = 0.434,
        Tcqdef = 0.447,
        Tcqdefx = 0.383,
        Tcqfast = 0.443,
        Tcqfastx = 0.383;
     if (   !RME )
       ( posedge CLK => (  Q[15]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[14]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[13]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[12]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[11]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[10]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[9]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[8]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[15]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[14]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[13]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[12]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[11]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[10]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[9]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[8]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[15]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[14]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[13]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[12]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[11]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[10]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[9]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[8]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[15]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[14]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[13]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[12]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[11]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[10]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[9]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[8]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[15]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[14]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[13]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[12]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[11]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[10]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[9]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[8]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );



// Timing Checks

  $width (negedge CLK &&& ENCLK, Tcl, 0, notif_clk);
  $width (posedge CLK &&& ENCLK, Tch, 0, notif_clk);
  $period (posedge CLK &&& ENCLK_rmezo, Tcc, notif_clk);
  $period (negedge CLK &&& ENCLK_rmezo, Tcc, notif_clk);
  $period (posedge CLK &&& ENCLK_vdm, Tccvddmin, notif_clk);
  $period (negedge CLK &&& ENCLK_vdm, Tccvddmin, notif_clk);
  $period (posedge CLK &&& ENCLK_slw, Tccslow, notif_clk);
  $period (negedge CLK &&& ENCLK_slw, Tccslow, notif_clk);
  $period (posedge CLK &&& ENCLK_def, Tccdef, notif_clk);
  $period (negedge CLK &&& ENCLK_def, Tccdef, notif_clk);
  $period (posedge CLK &&& ENCLK_fst, Tccfast, notif_clk);
  $period (negedge CLK &&& ENCLK_fst, Tccfast, notif_clk);

  $setuphold (posedge CLK  &&& ENADR, posedge ADR[0], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[0], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[1], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[1], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[2], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[2], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[3], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[3], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[4], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[4], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[5], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[5], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& END, posedge D[0], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[0], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[1], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[1], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[2], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[2], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[3], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[3], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[4], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[4], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[5], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[5], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[6], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[6], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[7], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[7], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[8], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[8], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[9], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[9], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[10], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[10], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[11], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[11], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[12], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[12], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[13], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[13], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[14], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[14], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[15], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[15], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& ENWE, posedge WE,Twc, Tcwx, notif_we );
  $setuphold (posedge CLK  &&& ENWE, negedge WE,Twc, Tcwx, notif_we );
  $setuphold (posedge CLK  &&& ENME, posedge ME,Tmc, Tcmx, notif_me );
  $setuphold (posedge CLK  &&& ENME, negedge ME,Tmc, Tcmx, notif_me );
  $hold (negedge CLK  &&& ENTEST1, posedge TEST1, Tct1x, notif_test1 );
  $hold (negedge CLK  &&& ENTEST1, negedge TEST1, Tct1x, notif_test1 );
  $setup ( posedge TEST1,posedge CLK  &&& ENTEST1, Tt1c, notif_test1 );
  $setup ( negedge TEST1,posedge CLK  &&& ENTEST1, Tt1c, notif_test1 );
  $setuphold (posedge CLK  &&& ENRM, posedge RM[0], Trmc, Tcrmx, notif_rm );
  $setuphold (posedge CLK  &&& ENRM, negedge RM[0], Trmc, Tcrmx, notif_rm );
  $setuphold (posedge CLK  &&& ENRM, posedge RM[1], Trmc, Tcrmx, notif_rm );
  $setuphold (posedge CLK  &&& ENRM, negedge RM[1], Trmc, Tcrmx, notif_rm );
  $setuphold (posedge CLK  &&& ENRM, posedge RM[2], Trmc, Tcrmx, notif_rm );
  $setuphold (posedge CLK  &&& ENRM, negedge RM[2], Trmc, Tcrmx, notif_rm );
  $setuphold (posedge CLK  &&& ENRM, posedge RM[3], Trmc, Tcrmx, notif_rm );
  $setuphold (posedge CLK  &&& ENRM, negedge RM[3], Trmc, Tcrmx, notif_rm );
  $setuphold (posedge CLK  &&& ENRME, posedge RME,Trmc, Tcrmx, notif_rme );
  $setuphold (posedge CLK  &&& ENRME, negedge RME,Trmc, Tcrmx, notif_rme );

endspecify
`endif // VIRAGE_FAST_VERILOG






`ifdef VIRAGE_FAST_VERILOG

generic_behav_asdrlspkb1p64x16cm2sw0 #(MES_ALL ,debug_mode) uut (  .Q (Q_buf), .ADR (ADR_buf), .D (D_buf), .WE(WE_buf), .ME(ME_buf), .CLK(CLK_buf), .TEST1(TEST1_buf), .RM (RM_buf), .RME(RME_buf) );

`else

generic_behav_asdrlspkb1p64x16cm2sw0 #(MES_ALL ,debug_mode) uut (  .Q (Q_buf), .ADR (ADR_buf), .D (D_buf), .WE(WE_buf), .ME(ME_buf), .CLK(CLK_buf), .TEST1(TEST1_buf), .RM (RM_buf), .RME(RME_buf),.notif_adr(notif_adr), .notif_d(notif_d), .notif_we(notif_we), .notif_me(notif_me), .notif_clk(notif_clk), .notif_test1(notif_test1), .notif_rm(notif_rm), .notif_rme(notif_rme) );

`endif // VIRAGE_FAST_VERILOG


always @( ADR_buf or negedge CLK_buf)
 begin
   if ( CLK_buf == 1'b0) ADR_pre = ADR_buf;
 end

always @( ME_buf or negedge CLK_buf)
  begin
    if ( CLK_buf == 1'b0) ME_pre = ME_buf;
  end

always @( WE_buf or negedge CLK_buf)
  begin
    if ( CLK_buf == 1'b0) WE_pre = WE_buf;
  end

always @( posedge CLK_buf)
begin
    ME_buf_L = ME_pre;
    WE_buf_L = WE_pre;
end  // end of always @( posedge CLK_buf)




endmodule
`endcelldefine 
`ifdef verifault 
`disable_portfaults 
`nosuppress_faults 
`endif 


`ifdef VIRAGE_FAST_VERILOG

module generic_behav_asdrlspkb1p64x16cm2sw0 (  Q, ADR, D, WE, ME, CLK, TEST1, RM, RME );

`else

module generic_behav_asdrlspkb1p64x16cm2sw0 (  Q, ADR, D, WE, ME, CLK, TEST1, RM, RME,notif_adr, notif_d, notif_we, notif_me, notif_clk, notif_test1, notif_rm, notif_rme );

`endif //VIRAGE_FAST_VERILOG

 parameter MES_ALL = "ON";
parameter debug_mode = 1;
parameter words = 64, bits = 16, addrbits = 6, timingmode = 1, rmbits=4;

output [bits-1:0] Q;
input [addrbits-1:0] ADR;
input [bits-1:0] D;
input WE;
input ME;
input CLK;
input TEST1;
input [rmbits-1:0] RM;
input RME;


    `ifdef  virage_ignore_read_addx
       parameter flag_ignore_read_addx = 0;
    `else
       parameter flag_ignore_read_addx = 1;
    `endif

`ifdef VIRAGE_FAST_VERILOG
`else
input notif_adr, notif_d, notif_we, notif_me, notif_clk, notif_test1, notif_rm, notif_rme;

`endif // VIRAGE_FAST_VERILOG

parameter DataX = { bits { 1'bx } };
parameter DataZ = { bits { 1'bz } };

reg  [bits-1:0]  Q_local;
wire [bits-1:0]  Q_blk;
reg [bits-1:0]  Q;

wire    [3:0] RM_set;
reg
        flaga_read_ok,
        flaga_we_ok,
        flaga_d_ok,
        flaga_rm_ok,
        flaga_adr_ok,
        flaga_range_ok;
reg     flaga_clk_valid;
reg     flaga_adr_x;

event   event_on_A_port;

reg  [addrbits-1:0] ADRlatched;
reg  [addrbits-1:0] ADR_old;
reg  [bits-1:0] Dlatched;
reg  [bits-1:0] D_old;
reg WElatched;
reg WE_old;
reg  TEST1latched;
reg  TEST1_old;
reg  MElatched;
reg  ME_old;
real CLK_TIME;

`ifdef VIRAGE_FAST_VERILOG
`else
`endif // VIRAGE_FAST_VERILOG

integer i;
reg  [bits-1:0] mem_core_array [0:words -1];
reg  [bits-1:0] mem_fault_array_XOR [0:words -1];
initial 
  begin
    for (i=0; i< words ; i=i+1)
      mem_fault_array_XOR[i]=0;
`ifdef MEMFAULTINJ
    if ($test$plusargs("asap_error"))
      mem_fault_array_XOR[1] = 1'b1 << (bits - 1);
`endif
  end


reg mes_all_valid;

initial
begin
  mes_all_valid = 0;
end

function is_adr_Valid;  // 1-bit return value
 input [addrbits-1:0] addr_to_check;
 reg     ret_value;
 begin
  ret_value = `True;
   if ((^addr_to_check) === 1'bx ) begin
    flaga_adr_x = `True;
    ret_value = `False;
   end
   if((addr_to_check > words -1) )
    begin
     ret_value = `False;
    end
   is_adr_Valid = ret_value;
end
endfunction

// -------------------------------------------------------------------
// Common tasks
// -------------------------------------------------------------------

// Task to report unknown messages
task report_unknown;
input [8*5:1] signal;
begin
    if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid )
    begin
      $display("<<%0s unknown>> at time=%t; instance=%m (RAMS1H)",signal,$realtime);
    end
end
endtask


task corrupt_all_loc;
 input flag_range_ok;
 integer addr_index;
 begin
                                     // do not corrupt entire memory if write to
                                    // out of range address, for all other cases
                                    // flag_range_ok is true, therefore corruption
                                    // will occur as before
  if( flag_range_ok == `True)
   begin
    for( addr_index = 0; addr_index < words; addr_index = addr_index + 1) begin
     mem_core_array[ addr_index] = DataX;
    end
   end
 end
endtask

task corrupt_cur_loc;
 input[addrbits-1:0] loc_to_corrupt;
  mem_core_array[loc_to_corrupt] = DataX;
endtask


always @( negedge CLK or WE )
   begin
       if ( CLK == 1'b0 )
       WE_old = WE;
   end
always @( negedge CLK or ADR )
   begin
       if ( CLK == 1'b0 )
       ADR_old = ADR;
   end
always @( negedge CLK or D )
   begin
       if ( CLK == 1'b0 )
       D_old = D;
   end
always @( negedge CLK or ME )
   begin
       if ( CLK == 1'b0 )
       ME_old = ME;
   end
always @( negedge CLK or TEST1 )
   begin
       if ( CLK == 1'b0 )
       TEST1_old = TEST1;
   end
// Perform Sanity Check on Port A, Corrupt memory if required

task checkSanityOnAport;

 #0                // let CLOCK and NOTIFIER stuff execute first
 case ( {flaga_adr_ok, flaga_we_ok, flaga_d_ok} ) // only 1 and 0

  3'b111   : ;                                                // everything ok!!!

  3'b101,
  3'b100   : corrupt_cur_loc(ADRlatched);          // WE is unstable

  3'b110   : if (WElatched !== 1'b0)
              corrupt_cur_loc(ADRlatched);         // Data is unstable
  3'b000,
  3'b001   : corrupt_all_loc(flaga_range_ok);            // ADR and WE unstable
  3'b010,
  3'b011   : if (WElatched !== 1'b0)    // ADR unstable, WE stable
              corrupt_all_loc(flaga_range_ok);
 endcase
endtask

// PORT A FUNCTIONALITY (Handle violation behavior)

initial
 begin
  flaga_adr_ok  = `True;
  flaga_range_ok = `True;
  flaga_we_ok   = `True;
  flaga_d_ok    = `True;
  flaga_read_ok = `True;
  flaga_rm_ok = `True;
  flaga_clk_valid = `True;
  flaga_adr_x = `False;
 end


`ifdef VIRAGE_FAST_VERILOG
`else

always @(notif_we)            // PORT A WE violation
 begin

    flaga_we_ok = `False;
    checkSanityOnAport;
    disable OUTPUT_0;
    flaga_read_ok = `False;
    -> event_on_A_port;
 end
always @(notif_clk)            // PORT A CLK violation
 begin

  disable OUTPUT_0;
  flaga_adr_ok = `False;
  flaga_we_ok  = `False;
  checkSanityOnAport;
  flaga_read_ok = `False;     // irrespective of WE
  -> event_on_A_port;
 end

always @(notif_me)            // PORT A ME violation
 begin

  flaga_adr_ok = `False;
  flaga_read_ok = `False;     // irrespective of WE
  disable OUTPUT_0;
  checkSanityOnAport;
  if (WElatched !== 1'b1 ) 
  -> event_on_A_port;
  corrupt_all_loc(`True);
 end


always @(notif_adr)           // PORT A ADR violation
 begin

    if (WElatched === 1'b0)
      begin
    corrupt_all_loc(`True);
    flaga_read_ok = `False; // irrespective of WE
    disable OUTPUT_0;
    -> event_on_A_port;
      end
     else  begin
    flaga_adr_ok = `False;
    flaga_read_ok = `False; // irrespective of WE
    disable OUTPUT_0;
    checkSanityOnAport;
   if (WElatched !== 1'b1) 
    -> event_on_A_port;
      end
 end

always @(notif_d)             // PORT A D violation
 begin

    flaga_d_ok = `False;
    disable OUTPUT_0;
    checkSanityOnAport;
 end

always @(notif_test1)               //PORT A TEST1 violation
 begin
    disable OUTPUT_0;
    flaga_read_ok = `False;
  if (WElatched !== 1'b1 ) 
    -> event_on_A_port;
    flaga_d_ok  = `False;
    checkSanityOnAport;
 end

always @(notif_rm)               //PORT A RM violation
 begin
    disable OUTPUT_0;
    flaga_read_ok = `False;
    -> event_on_A_port;
    flaga_d_ok  = `False;
    checkSanityOnAport;
 end
always @(notif_rme)               //PORT A RMEN violation
 begin
    disable OUTPUT_0;
    flaga_read_ok = `False;
    -> event_on_A_port;
    flaga_d_ok  = `False;
    checkSanityOnAport;
 end



`endif // VIRAGE_FAST_VERILOG


always @(negedge CLK)          // reset for next cycle
 begin
  if ( CLK !== 1'bx ) begin
   #0.001;
   flaga_range_ok  = `True;
   flaga_read_ok = `True;
   flaga_rm_ok = `True;
   flaga_clk_valid = `True;
   flaga_adr_x = `False;
  end
  else
  begin
    report_unknown("CLK");
    flaga_clk_valid = `False;
    Q_local =  DataX;
    corrupt_all_loc(`True);
   end
 end

// PORT A FUNCTIONALITY (Handle normal read/write)

always @(posedge CLK)
begin
  flaga_adr_ok  = `True;
  flaga_we_ok   = `True;
  flaga_d_ok    = `True;

  if (CLK === 1'bx)
  begin
    report_unknown("CLK");
    flaga_clk_valid = `False;
    Q_local =  DataX;
    corrupt_all_loc(`True);
  end // end of if (CLK === 1'bx)

  CLK_TIME = $realtime;
  MElatched = ME_old;
  WElatched = WE_old;
  TEST1latched = TEST1_old;
  ADRlatched = ADR_old;
  Dlatched = D_old;
    if ((^Dlatched === 1'bx) && MElatched == 1'b1)
    begin
      if (Dlatched === 16'bx)
      begin
        flaga_d_ok  = `False;
      end
      if (WElatched !== 1'b0)
      begin
        report_unknown("D");
      end  
    end



  if (!flaga_clk_valid) begin
    Q_local =  DataX;
  end 
  else
  begin
    if (MElatched!== 1'b0)
    begin
      if (TEST1latched === 1'bx)
      begin
        report_unknown("TEST1");
        if (WElatched === 1'b1)
        begin
          flaga_adr_ok = `False;
        end
        Q_local = 16'bx;
        flaga_read_ok = `False;
      end
      if (WElatched === 1'bx)
      begin
        report_unknown("WE");
        flaga_we_ok = `False;
        flaga_read_ok = `False;
      end
      if (MElatched !== 1'b1)
       flaga_we_ok = `False;       // don't know if cycle is On or Off
      if (is_adr_Valid(ADRlatched) != `True ) begin
       if ( flaga_adr_x ) begin
         report_unknown("ADR");
       end
       flaga_adr_ok = `False;
       if( !(flaga_adr_x) )
       begin
         if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid == 1'b1)
         $display("\n%m VIRL_MEM_WARNING:address ADR is out of range, RANGE:0 to 63\n");
         flaga_range_ok = `False;
       end
      else
      begin
        if (WElatched === 1'b0 && MElatched === 1'b1 && flag_ignore_read_addx == 1)
          corrupt_all_loc(`True);
      end
      end

      if ( MElatched === 1'bx )
      begin
         report_unknown("ME");
        if (WElatched !== 1'b1)
          Q_local =  DataX;
        if ( !(WElatched == 1'b0 && flag_ignore_read_addx == 0) )
          corrupt_all_loc(flaga_range_ok);
      end
      else
      begin
         if (flaga_we_ok && flaga_adr_ok && flaga_d_ok && (WElatched == 1'b1))
         begin
           mem_core_array[ADRlatched] = Dlatched;  // write data in
           if (mes_all_valid == 0) mes_all_valid = 1;
	 end
         else
         begin
           checkSanityOnAport;
         end


        if (flaga_we_ok == `False) 
         flaga_read_ok = `False;
        if (TEST1latched == 1 )
        begin
          #0.001;
          flaga_read_ok = `False;
          -> event_on_A_port;
          @(negedge CLK)
          -> event_on_A_port;
        end
        else
        -> event_on_A_port;
       end
     end
   end
 end


// START OF PORT A READ-OUT BLOCK 

always @(event_on_A_port)
begin
  #0 // let CLOCK and NOTIFIER module execute first
  if (RME === 1'b1)
  begin
    if (RM_set >= 4'b0100)
    begin
      if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid == 1'b1)
      begin
       $display("VIRL_MEM_WARNING: RM = %b is not recommended value ; time = %t, instance = %m (asdrlspkb1p64x16cm2sw0_core)",RM,$realtime);
      end
    end
  end
  else
  begin
  if (RM_set != 4'b0010)
  begin
    if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid == 1'b1)
    begin
      $display("VIRL_MEM_WARNING: RM = %b is not recommended value ; time = %t, instance = %m (asdrlspkb1p64x16cm2sw0_core)",RM,$realtime);
    end // MES_ALL=="ON"
  end // RM_set != 4'b0010
  end
  if (^RM_set === 1'bx) begin
    flaga_rm_ok = `False;
    if (RME !== 1'bx) begin
      report_unknown("RM");
    end
  end
    if (flaga_adr_ok && (ADRlatched <= words -1) && flaga_read_ok && flaga_rm_ok) begin : OUTPUT_0
      if (WElatched == 1'b0 )
      begin
        `ifdef VIRAGE_FAST_VERILOG
        `else
           Q_local = DataX;
        `endif // VIRAGE_FAST_VERILOG
          `ifdef VIRAGE_FAST_VERILOG
          `else
             #0.001
          `endif // VIRAGE_FAST_VERILOG
          
            Q_local = mem_core_array[ADRlatched]^mem_fault_array_XOR[ADRlatched];

            if (mes_all_valid == 0) mes_all_valid = 1;
      end // else WE
    end // end of if (flaga_adr_ok && (ADRlatched))
    else
    begin
        if (WElatched != 1'b1 || !flaga_we_ok) 
        Q_local =   DataX;
        flaga_read_ok = `True;
   end
end // end of always @(event_on_A_port

// END OF PORT A READ-OUT BLOCK



assign Q_blk = Q_local;


always @(Q_blk)
begin : nonblocking_blk_0
   Q <= Q_blk;
end


// START OF PORT A OUTPUT ENABLE BLOCK



always @ (TEST1)
begin
  if ( CLK === 1'b1 && MElatched === 1'b1 )
  begin
    if (WElatched === 1'b1 )
    begin
      corrupt_cur_loc(ADRlatched);
    end
    Q_local = 16'bx;
    flaga_read_ok = `False;
  end
  if ( TEST1 == 1'b1)
  begin
    if(MES_ALL=="ON" && $realtime != 0 && mes_all_valid)
    begin
      $display("\n%m VERILOG> VIRL_MEM_WARNING: Tcc value in the RAM model is for TEST1=1'b0,but input value is TEST1=1'b1 (time %0t)\n\n", $time);
    end
  end
end

assign RM_set = (RME === 1'b0) ? 4'b0010:((RME === 1'b1) ? RM: 4'bx);
endmodule
